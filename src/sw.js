import { precacheAndRoute } from 'workbox-precaching'

// Precache all assets generated by Vite
precacheAndRoute(self.__WB_MANIFEST)

// Activate immediately on install (no waiting for old SW to die)
self.addEventListener('install', () => {
    self.skipWaiting();
});

self.addEventListener('activate', (event) => {
    event.waitUntil(self.clients.claim());
});

// Helper for IndexedDB access in Service Worker
const getFromIDB = (key) => {
    return new Promise((resolve) => {
        const request = indexedDB.open('japa-settings', 1);
        request.onupgradeneeded = (e) => e.target.result.createObjectStore('settings');
        request.onsuccess = (e) => {
            const db = e.target.result;
            const transaction = db.transaction('settings', 'readonly');
            const store = transaction.objectStore('settings');
            const getRequest = store.get(key);
            getRequest.onsuccess = () => resolve(getRequest.result);
            getRequest.onerror = () => resolve(null);
        };
        request.onerror = () => resolve(null);
    });
};

// Function to show the notification
const showReminder = (isTest = false) => {
    self.registration.showNotification(isTest ? 'Japa Test Notification ðŸŒ¸' : 'Naam Japa Reminder', {
        body: isTest ? 'Your notification system is working perfectly! Radhe Radhe! ðŸ™' : 'Radhe Radhe! It is time for your sacred Naam Japa. ðŸ™',
        icon: '/icon.svg',
        badge: '/icon.svg',
        vibrate: [200, 100, 200],
        tag: isTest ? 'japa-test' : 'japa-reminder',
        renotify: true,
        data: {
            url: '/'
        }
    });
};

// Check if it's time to show a reminder
const checkAndFireReminder = async () => {
    const settings = await getFromIDB('notificationSettings');
    if (!settings || !settings.enabled) return;

    const now = new Date();
    const [targetH, targetM] = settings.time.split(':').map(Number);

    if (now.getHours() === targetH && now.getMinutes() === targetM) {
        // Check if we already fired this minute (prevent duplicates)
        const lastFired = await getFromIDB('lastFiredMinute');
        const currentKey = `${now.getFullYear()}-${now.getMonth()}-${now.getDate()}-${targetH}-${targetM}`;

        if (lastFired !== currentKey) {
            // Save that we fired this minute
            const writeRequest = indexedDB.open('japa-settings', 1);
            writeRequest.onsuccess = (e) => {
                const db = e.target.result;
                const tx = db.transaction('settings', 'readwrite');
                tx.objectStore('settings').put(currentKey, 'lastFiredMinute');
            };
            showReminder();
        }
    }
};

// Listen for messages from the main thread
self.addEventListener('message', async (event) => {
    if (!event.data) return;

    switch (event.data.type) {
        case 'TEST_NOTIFICATION':
            showReminder(true);
            break;
        case 'SCHEDULE_NOTIFICATION':
            // Settings are already saved to IDB by the main thread.
            // Just acknowledge and do an immediate check.
            console.log('[SW] Received schedule update:', event.data);
            await checkAndFireReminder();
            break;
        case 'CHECK_REMINDER':
            // Main thread is asking us to check if it's reminder time
            await checkAndFireReminder();
            break;
    }
});

// Background Timer - runs when SW is active (30s interval)
setInterval(async () => {
    await checkAndFireReminder();
}, 30000);

// Also check on SW activation
self.addEventListener('activate', (event) => {
    event.waitUntil(checkAndFireReminder());
});

// Handle notification click
self.addEventListener('notificationclick', (event) => {
    event.notification.close();
    event.waitUntil(
        clients.matchAll({ type: 'window', includeUncontrolled: true }).then((clientList) => {
            if (clientList.length > 0) {
                let client = clientList[0];
                for (let i = 0; i < clientList.length; i++) {
                    if (clientList[i].focused) {
                        client = clientList[i];
                    }
                }
                return client.focus();
            }
            return clients.openWindow('/');
        })
    );
});
